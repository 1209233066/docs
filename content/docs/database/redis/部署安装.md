---
date: '2025-08-01T10:10:00+08:00'
draft: false
title: '安装部署'
linkTitle: '安装部署'
type: blog
toc_hide: false
hide_summary: true
weight: 1
description: >
  redis部署安装
tags: ["安装部署"]
categories: ["redis"]
url: redis/install.html
author: "wangendao"
---



redis（*remote dictionary server*） 是开源的k-v[数据库](https://db-engines.com/en/ranking)，使用内存存储，主要定位为数据缓存。除此之外还可以用于 *session 共享*，*排行榜、计数器*，*消息队列*



<table>
    <td><a href=#redis部署之单节点>redis部署之单节点</a></td>
    <td><a href=#redis部署之主从>redis部署之主从</a></td>
    <td><a href=#redis部署之哨兵>redis部署之哨兵</a></td>
    <td><a href=#redis部署之集群>redis部署之集群</a></td>
</table>



<span id=redis部署之单节点><font color=red size=4px>redis部署之单节点</font></span>

1. 部署安装

   ```bash
   wget http://download.redis.io/releases/redis-5.0.14.tar.gz
   ```

   ```bash
   tar xf redis-5.0.14.tar.gz && cd redis-5.0.14
   ```

   ```bash
   make && make PREFIX=/opt/redis install 
   ```

   二进制文件介绍

   | 命令               | 释义               |
   | ------------------ | ------------------ |
   | `redis-server`     | 启动server         |
   | `redis-cli`        | 客户端工具         |
   | `redis-benchmark`  | 基准测试工具       |
   | `redis-check-aof`  | aof 检测和修复工具 |
   | `redis-check-dump` | rdb 检测和修复工具 |
   | `redis-sentinel`   | 启动 sentinel      |

2. 启动服务

   ```bash
   /opt/redis/bin/redis-server
   ```

<span id=redis部署之主从><font color=red size=4px>redis部署之主从</font></span>

> <sub>主从架构在单节点基础上提供了数据的冗余能力，提升了redis的读取能力</sub>


1. 部署安装

   参照 <a href=#redis部署之单节点>redis部署之单节点</a>

2. 启动服务

   > <sub>【支持三种配置方式：】</sub>
   >
   > <sub>1. 在启动命令中添加` --SLAVEOF 10.4.7.251 6379`</sub>
   >
   > <sub>2. 通过redis-cli 登录到redis 执行 `slaveof 10.4.7.251 6379`</sub>
   >
   > <sub>3. 在redis.conf配置文件中写入 `slaveof 10.4.7.251 6379`</sub>

   

   ```bash
   /opt/redis/bin/redis-server --bind 10.4.7.251 --port 6379 --daemonize yes --protected-mode no 
   ```

   ```bash
   /opt/redis/bin/redis-server --bind 10.4.7.251 --port 6380 --daemonize yes  --protected-mode no --SLAVEOF 10.4.7.251 6379
   ```

   ```bash
   /opt/redis/bin/redis-server --bind 10.4.7.251 --port 6381 --daemonize yes  --protected-mode no --SLAVEOF 10.4.7.251 6379
   ```

   确认主从关系

   ```bash
   [root@master01 ~]# /opt/redis/bin/redis-cli -h 10.4.7.251 -p 6379 info replication
   # Replication
   role:master
   connected_slaves:2
   slave0:ip=10.4.7.251,port=6380,state=online,offset=56,lag=0
   slave1:ip=10.4.7.251,port=6381,state=online,offset=56,lag=0
   ...
   ```

3. 测试主从切换

   首先观察从节点复制偏移量 

   ```bash
   /opt/redis/bin/redis-cli -h 10.4.7.251 -p 6380 info replication|grep master_repl_offset
   ```

   ```bash
   /opt/redis/bin/redis-cli -h 10.4.7.251 -p 6381 info replication|grep master_repl_offset
   ```

   选择一个偏移量最大的从节点，执行切换为主节点。当前环境我们把 `10.4.7.251:6381`切换为新的主节点。其他节点从新建立与该节点的主从关系

   ```bash
   /opt/redis/bin/redis-cli -h 10.4.7.251 -p 6381 slaveof no one
   ```

   ```bash
   /opt/redis/bin/redis-cli -h 10.4.7.251 -p 6381 role
   ```

   ```bash
   /opt/redis/bin/redis-cli -h 10.4.7.251 -p 6379 SLAVEOF 10.4.7.251 6381
   ```

   ```bash
   /opt/redis/bin/redis-cli -h 10.4.7.251 -p 6380 SLAVEOF 10.4.7.251 6381
   ```

4. 复制原理及相关参数

   **复制原理**

       1. 从库通过slaveof 指令连接到master，并发起sync请求
       2. master确认后，派生子线程bgsave生成rdb快照，并将快照传递给salve
       3. salve接收到rdb快照后，清空本机rdb,加载主库传递过来的rdb 到内存
       4. 以上完成后，master 会将变更数据缓存到本地 buffer中，按照一定规则传递给slave。允许从节点在短时间与主节点断开。

   | 复制相关参数                 | 解释                          |
   | ---------------------------- | ----------------------------- |
   | `repl-backlog-szie 1M`       | 环形复制积压缓冲区。最小值16k |
   | `repl-diskless-sync yes`     | 开启无盘复制                  |
   | `repl-diskless-sync-delay 5` | 无盘复制延迟等待时长          |



<span id=redis部署之哨兵><a herf=https://redis.io/docs/management/sentinel/><font color=red size=4px>redis部署之哨兵</font></a></span>

> <sub>哨兵集群是对主从的扩展，提供了主节点故障的自动转移并通知应用方能力。Redis从2.8开始正式 提供了Redis Sentinel</sub>



架构：

```bash
       +----+
       | M1 |
       | S1 |
       +----+
          |
+----+    |    +----+
| R2 |----+----| R3 |
| S2 |         | S3 |
+----+         +----+

Configuration: quorum = 2
```



1. 部署安装

   参照<a href=#redis部署之单节点>redis部署之单节点</a>

2. 启动服务

   参照<a href=#redis部署之主从>redis部署之主从</a>

3. 配置sentinel

   > <sub>Master-specific configuration parameters are modified using：`SENTINEL SET`</sub>
   >
   > <sub>Global configuration parameters are modified using `SENTINEL CONFIG SET`.</sub>

   ```bash
   tee redis-sentinel.conf <<EOF
   daemonize yes
   # mymaster 为该集群起一个别名。一个sentinel 可以同时监控多个集群，因此使用别名区分
   # redis master的地址和端口10.4.7.251 6379
   # 2 表示有2个sentinel 判断master失败后才进行主从切换
   sentinel monitor mymaster 10.4.7.251 6379 2
   # 每个Sentinel节点都要通过定期发送ping命令来判断Redis数据节点和其
   # 余Sentinel节点是否可达，如果超过了down-after-milliseconds配置的时间且没
   # 有有效的回复，则判定节点不可达 30000ms
   sentinel down-after-milliseconds mymaster 30000
   # 选举出新的主节点后，同时向主节点执行psync的从节点个数
   sentinel parallel-syncs mymaster 1
   # 故障转移超时时间 180000ms（选举新的主节点+从节点完成主从复制）
   sentinel failover-timeout mymaster 180000
   # 设置sentinel 密码
   sentinel auth-pass mymaster 123456
   #sentinel auth-pass mymaster 12345
   #### 一组sentinel 支持多个主从集群
   #sentinel monitor resque 192.168.1.3 6380 2
   #sentinel down-after-milliseconds resque 10000
   #sentinel failover-timeout resque 180000
   #sentinel parallel-syncs resque 5
   
   
   EOF
   ```

4. 启动sentinel【默认监听26379】

   > <sub>【sentinel 的启动方式有2种：】</sub>
   >
   > <sub>`redis-sentinel /path/to/sentinel.conf`</sub>
   >
   > <sub>`redis-server /path/to/sentinel.conf --sentinel`</sub>

   

   ```bash
   mkdir /tmp/{26379,26380,26381}
   ```

   ```bash
   /opt/redis/bin/redis-server redis-sentinel.conf --sentinel \
   --bind 10.4.7.251 \
   --port 26379 \
   --dir /tmp/26379 \
   --logfile /tmp/26379.log
   ```

   ```bash
   /opt/redis/bin/redis-server redis-sentinel.conf --sentinel \
   --bind 10.4.7.251 \
   --port 26380 \
   --dir /tmp/26380 \
   --logfile /tmp/26380.log
   ```

   ```bash
   /opt/redis/bin/redis-server redis-sentinel.conf --sentinel \
   --bind 10.4.7.251 \
   --port 26381 \
   --dir /tmp/26381 \
   --logfile /tmp/26381.log
   ```

   ```bash
   /opt/redis-4.2/bin/redis-server ./redis-4.0.2/redis-sentinel17778.conf --port 17778 --sentinel --protected-mode no  --logfile /tmp/17778.log 
   /opt/redis-4.2/bin/redis-server ./redis-4.0.2/redis-sentinel17779.conf --port 17779 --sentinel --protected-mode no --logfile /tmp/17779.log
   /opt/redis-4.2/bin/redis-server ./redis-4.0.2/redis-sentinel17777.conf --port 17777 --sentinel --protected-mode no --logfile /tmp/17777.log
   ```

   

5. 验证状态

   ```bash
   [root@master01 ~]# /opt/redis/bin/redis-cli -p 26379 -h 10.4.7.251
   10.4.7.251:26379> info sentinel
   # Sentinel
   sentinel_masters:1
   sentinel_tilt:0
   sentinel_running_scripts:0
   sentinel_scripts_queue_length:0
   sentinel_simulate_failure_flags:0
   master0:name=mymaster,status=ok,address=10.4.7.251:6379,slaves=2,sentinels=2
   
   #ok  状态正常
   #sdown 主观下线
   #odown 客观下线
   #Redis Sentinel 有两种不同的宕机概念，一种称为 主观上为 Down 条件 （SDOWN），并且是 local 添加到给定的 Sentinel 实例。另一个称为客观关闭条件 （ODOWN），当有足够的 Sentinel（至少 number 配置为被监控 master 的参数）具有 SDOWN 条件
   ```

   

   

6. 验证主宕机

   ```bash
   /opt/redis/bin/redis-cli -p 6379 -h 10.4.7.251 shutdown 
   ```

   sentinel 节点30s 后标记节点主观（Subjectively）下线

   ```bash
   sentinel1_1  | 1:X 15 Apr 2024 08:40:26.982 # +sdown master mymaster 10.4.7.251 6379
   sentinel2_1  | 1:X 15 Apr 2024 08:40:26.983 # +sdown master mymaster 10.4.7.251 6379
   sentinel3_1  | 1:X 15 Apr 2024 08:40:27.032 # +sdown master mymaster 10.4.7.251 6379
   ```
   
   

   等待30s 后选出主节....
   
   
   
   重新启动宕机的节点，会自动加入到该主从中
   
   ```bash
    /opt/redis/bin/redis-server --bind 10.4.7.251 --port 6379 --daemonize yes
   ```
   
   
   
   
   
   | 命令                                    | 解释                                                  |
   | --------------------------------------- | ----------------------------------------------------- |
   | `sentinel master mymaster`              | 查询主节点状态                                        |
   | `sentinel slaves mymaster`              | 查询从节点状态。或者命令 `sentinel replicas mymaster` |
   | `sentinel sentinels mymaster`           | 查询除自己外的sentinel节点信息                        |
   | `sentinel get-master--by-name mymaster` | 查询主节点的ip:port                                   |
   | ` sentinel ckquorum mymaster`           | 检查哨兵集群是否满足切换需求                          |
   | `sentinel flushconfig`                  | 强制将sentinel 配置写入磁盘                           |
   | `sentinel failover mymaster`            | 强制主从切换                                          |
   | `sentinel info-cache`                   | 返回master-slave的缓存信息                            |
   | `sentinel config get *`                 | 获取sentinel 配置信息 >=6.2                           |
   | `sentinel config set <key> <value>`     | 动态设置sentinel 配置 >=6.2                           |
   
   
   
   
   
   
   
   



<span id=redis部署之集群><font color=red size=4px>redis部署之集群</font></span>

> <sub>redis cluster 是redis 的分布式解决方案，在3.0后正式推出。其主要解决**单节点写能力**和**存储能力**受限的问题。</sub>
>
> <sub>Redis集群相对单机在功能上存在一些限制，需要开发人员提前了解， 在使用时做好规避。限制如下：</sub>
>
> <sub>1）key批量操作支持有限。如mset、mget，目前只支持具有相同slot值的 key执行批量操作。对于映射为不同slot值的key由于执行mset、mget等操作可能存在于多个节点上因此不被支持。<br>2）key事务操作支持有限。同理只支持多key在同一节点上的事务操作，当多个key分布在不同的节点上时无法使用事务功能。<br>3）key作为数据分区的最小粒度，因此不能将一个大的键值对象如 hash、list等映射到不同的节点。<br>4）不支持多数据库空间。单机下的Redis可以支持16个数据库，集群模式下只能使用一个数据库空间，即db0。<br>5）复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复制结构。</sub>



**部署方法一：**

1. 部署安装

   参照 <a href=#redis部署之单节点>redis部署之单节点</a>

2. 启动服务

   ```bash
   for port in {6379,6380,6381};do
   	/opt/redis/bin/redis-server \
   	--bind 0.0.0.0 --port ${port} \
   	--daemonize yes \
   	--cluster-enabled yes \
   	--cluster-config-file /opt/redis_${port}/nodes.conf \
   	--logfile  /opt/redis_${port}/redis.log \
   	--cluster-node-timeout 1500 \
   	--requirepass pytc@2024
   done
   ```

   

3. 创建集群

   ```bash
   /opt/redis/bin/redis-cli -a pytc@2024 --cluster create 192.168.0.216:6379 192.168.0.216:6380 192.168.0.216:6381 --cluster-replicas 0
   ```

   

**部署方法二：**

1. 部署安装

   参照 <a href=#redis部署之单节点>redis部署之单节点</a>

2. 启动服务

   ```bash
   /opt/redis/bin/redis-server --bind 10.4.7.251 --port 6379 --daemonize yes  --cluster-enabled yes --cluster-config-file nodes-6379.conf --cluster-node-timeout 1500
   ```

   ```bash
   /opt/redis/bin/redis-server --bind 10.4.7.251 --port 6380 --daemonize yes  --cluster-enabled yes --cluster-config-file nodes-6380.conf --cluster-node-timeout 1500
   ```

   ```bash
   /opt/redis/bin/redis-server --bind 10.4.7.251 --port 6381 --daemonize yes  --cluster-enabled yes --cluster-config-file nodes-6381.conf --cluster-node-timeout 1500
   ```

3. 安装ruby环境

   ```bash
   rpm -e ruby --nodeps
   wget https://github.com/postmodern/ruby-install/archive/refs/tags/v0.8.5.tar.gz
   tar xf v0.8.5.tar.gz
   cd ruby-install-0.8.5/
   make install
   ruby-install --system ruby 2.6.10
   ```

4. 安装redis-trib 工具

   ```bash
   # gem 是ruby的包管理工具，可以类比python的pip
   yum install rubygems redis-trib -y
   
   gem sources
   gem sources --remove https://rubygems.org/
   gem sources -a https://mirrors.aliyun.com/rubygems/
   gem install redis
   ```

5. 创建集群

   ```bash
   redis-trib create --replicas 0 \
   10.4.7.251:6379 10.4.7.251:6380 10.4.7.251:6381
   ```



**部署方法三：**

1. 部署安装

   参照 <a href=#redis部署之单节点>redis部署之单节点</a>

2. 启动服务

   ```bash
   /opt/redis/bin/redis-server --bind 10.4.7.251 --port 6379 --daemonize yes  --cluster-enabled yes --cluster-config-file nodes-6379.conf --cluster-node-timeout 1500
   ```

   ```bash
   /opt/redis/bin/redis-server --bind 10.4.7.251 --port 6380 --daemonize yes  --cluster-enabled yes --cluster-config-file nodes-6380.conf --cluster-node-timeout 1500
   ```

   ```bash
   /opt/redis/bin/redis-server --bind 10.4.7.251 --port 6381 --daemonize yes  --cluster-enabled yes --cluster-config-file nodes-6381.conf --cluster-node-timeout 1500
   ```

3. 加入集群

   ```bash
   /opt/redis/bin/redis-cli -h 10.4.7.251 cluster meet 10.4.7.251 6380
   ```

   ```bash
   /opt/redis/bin/redis-cli -h 10.4.7.251 cluster meet 10.4.7.251 6381
   ```

   

4. 分配槽位

   ```bash
   /opt/redis/bin/redis-cli -h 10.4.7.251 cluster addslots {0..5460}
   ```

   ```bash
   /opt/redis/bin/redis-cli -h 10.4.7.251 -p 6380 cluster addslots {5461..10921}
   ```

   ```
   /opt/redis/bin/redis-cli -h 10.4.7.251 -p 6381 cluster addslots {10922..16383}
   ```

5. 建立主从关系



**新增分片**

```bash
redis-cli --cluster add-node 127.0.0.1:7006 127.0.0.1:7000
```

```bash
$ redis-cli -p 7000 cluster nodes
46a768cfeadb9d2aee91ddd882433a1798f53271 127.0.0.1:7006@17006 master - 0 1616754504000 0 connected
1f2bc068c7ccc9e408161bd51b695a9a47b890b2 127.0.0.1:7003@17003 slave a138f48fe038b93ea2e186e7a5962fb1fa6e34fa 0 1616754504551 3 connected
5b4e4be56158cf6103ffa3035024a8d820337973 127.0.0.1:7001@17001 master - 0 1616754505584 2 connected 5461-10922
a138f48fe038b93ea2e186e7a5962fb1fa6e34fa 127.0.0.1:7002@17002 master - 0 1616754505000 3 connected 10923-16383
71e078dab649166dcbbcec51520742bc7a5c1992 127.0.0.1:7005@17005 slave 5b4e4be56158cf6103ffa3035024a8d820337973 0 1616754505584 2 connected
f224ecabedf39d1fffb34fb6c1683f8252f3b7dc 127.0.0.1:7000@17000 myself,master - 0 1616754502000 1 connected 0-5460
04d71d5eb200353713da475c5c4f0a4253295aa4 127.0.0.1:7004@17004 slave f224ecabedf39d1fffb34fb6c1683f8252f3b7dc 0 1616754505896 1 connect
```

添加从节点

```bash
$ redis-cli -p 7000 --cluster add-node 127.0.0.1:7007 127.0.0.1:7000 --cluster-slave --cluster-master-id 46a768cfeadb9d2aee91ddd882433a1798f53271
```

为新分片分配slot

```bash
$ redis-cli -p 7000 --cluster reshard 127.0.0.1:7000
....
....
....

How many slots do you want to move (from 1 to 16384)? 4096
What is the receiving node ID? 46a768cfeadb9d2aee91ddd882433a1798f53271
Please enter all the source node IDs.
  Type 'all' to use all the nodes as source nodes for the hash slots.
  Type 'done' once you entered all the source nodes IDs.
Source node #1: all

Ready to move 4096 slots.
  Source nodes:
	M: f224ecabedf39d1fffb34fb6c1683f8252f3b7dc 127.0.0.1:7000
   	slots:[0-5460] (5461 slots) master
   	1 additional replica(s)
	M: 5b4e4be56158cf6103ffa3035024a8d820337973 127.0.0.1:7001
   	slots:[5461-10922] (5462 slots) master
   	1 additional replica(s)
	M: a138f48fe038b93ea2e186e7a5962fb1fa6e34fa 127.0.0.1:7002
   	slots:[10923-16383] (5461 slots) master
   	1 additional replica(s)
  Destination node:
	M: 46a768cfeadb9d2aee91ddd882433a1798f53271 127.0.0.1:7006
   	slots: (0 slots) master
   	1 additional replica(s)
  Resharding plan:
	Moving slot 5461 from 5b4e4be56158cf6103ffa3035024a8d820337973
	Moving slot 5462 from 5b4e4be56158cf6103ffa3035024a8d820337973

Do you want to proceed with the proposed reshard plan (yes/no)? 
Moving slot 5461 from 127.0.0.1:7001 to 127.0.0.1:7006:
Moving slot 5462 from 127.0.0.1:7001 to 127.0.0.1:7006:
Moving slot 5463 from 127.0.0.1:7001 to 127.0.0.1:7006:
```



