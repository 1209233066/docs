---
title: "数据类型"
linkTitle: "数据类型"
date: 2025-05-09
toc_hide: false
hide_summary: true
weight: 3
description: >
  go|数据类型

tags: ["golang","数据类型"]
categories: ["golang"]
url: golang/type.html
---
golang 中数据类型分为基本数据类型和复合数据类型，常量只能使用基本数据类型，变量可以使用全部数据类型。



### 基本数据类型

<table>
    <tr>
        <td>数值型（整数、浮点数、复数）</td>
        <td>字符串</td>
        <td>布尔型</td>
    </tr>
</table>

**数值型（整数、浮点数、复数）**

+ 按照取值范围可以分为：`int`,`int8`, `int16` ,`int32` `int64`,`uint`,`uint8` `uint16` ,`uint32`, `uint64` ,`float32`,`float64`

  ```go
  package main
  
  import "fmt"
  
  func main() {
  	var weigh, price float32 = 100.1, 9.99
  	// %T 查看数据类型
  	fmt.Printf("数据类型：%T\n数据类型：%T\n", weigh, price)
  }
  ```



**字符串**

+ 获取字符串长度和字符串切片

  ```go
  package main
  
  import "fmt"
  
  func main() {
  	// len 获取字符串长度
  	var message = `相对于技术革新的速度，人性数千年的变换却是渺小的`
  	fmt.Printf("%s\n占用%dbytes\n", message, len(message))
  	// 字符串切片，一个汉字占用3个字符
  	// substr := message[:]
  	// substr := message[0]
  	substr := message[0:3]
  	fmt.Printf("%s\n", substr)
  }
  ```

  



**布尔型**

+ bool 数据类型取值范围 `true` 和 `false`

  ```go
  package main
  
  import "fmt"
  
  func main() {
  	var overall bool
  	overall = true
  	fmt.Printf("数据类型：%T\n", overall) //数据类型：bool
  }
  ```

  





### 复合数据类型

<table>
    <tr>
        <td>指针 pointer</td>
        <td>数组 arrary</td>
        <td>切片 slice</td>
        <td>集合 map</td>
        <td>结构体 struct</td>
		<td>接口 interface</td>
    </tr>
</table>


#### **指针 pointer**

指针保存了变量的内存地址，可以是` *int *float64 *bool *string` 

指针类型变量声明:

```go
var <name> *[type] = [value]
```

+ `var` 关键字，表示声明一个变量
+ `<name>` 变量名称
+ `*[type]`  type为引用的数据类型

示例：

```go
package main

import "fmt"

func main() {
	age := 32
	var Age = &age
	fmt.Printf("数据类型：%T\n变量中存储的值:%d\n变量内存引用的值：%d\n", Age, Age, *Age)
	// 	数据类型：*int
	// 变量中存储的值:824634916864
	// 变量内存引用的值：32
}
```

空指针

> 只声明未赋值的指针成为空指针,编码过程中避免出现空指针

```go
package main

import "fmt"

func main() {
	// 只声明未赋值的指针成为空指针
	var Age *int
	fmt.Print(Age) //nil
	fmt.Println(*Age) //<nil>panic: runtime error: invalid memory address or nil pointer dereference
}
```



#### **数组 array**

存放相同数据类型的集合，长度相对固定，有序

声明语法：

```go
var <name> [size]type
```

+ `var` 关键字，表示声明一个变量
+ `<name>` 变量名称
+ `[size]string`  指定数据元素`size`,元素类型为 `type`等

示例

```go
package main

import "fmt"

// 数值的特征： 存放相同类型，有序，定长
func main() {
	// 定义数组 var <name> [size]string
	var lang [3]string
	lang[0] = "python"
	lang[1] = "go"
	lang[2] = "java"
	fmt.Printf(
		"数据类型：%T\n存储的值：%s\n数组长度%d\n",
		lang, lang[0], len(lang),
	)
	// 定义并赋值
	var lang1 = [3]string{"python", "go", "java"}
	fmt.Printf(
		"数据类型：%T\n存储的值：%s\n数组长度%d\n",
		lang1, lang1[0], len(lang1),
	)
	// 简短定义并赋值，只能在函数里使用
	lang2 := [3]string{"python", "go"}
	fmt.Printf(
		"数据类型：%T\n存储的值：%s\n数组长度%d\n",
		lang2, lang2, len(lang2),
	)
	// 定义不定长数组
	lang3 := [...]string{"python", "go", "java"}
	fmt.Printf(
		"数据类型：%T\n存储的值：%s\n数组长度%d\n",
		lang3, lang3, len(lang3),
	)
	for i := 0; i < len(lang3); i++ {
		fmt.Printf("%d -- %s\n", i, lang3[i])
	}
}
```

指针类型的数组

> 存放一种类型数据的指针

```go
package main

import "fmt"

func main() {

	var lang [3]*string
	a := "python"
	lang[0] = &a
	fmt.Printf("数据类型：%T\n存储的值：%s\n", lang, *lang[0])
}

// 数据类型：[3]*string
// 存储的值：python
```

使用new 创建 *数组指针*

> 定义了一个 数组类型 的指针，这一部分应该放在指针章节

```go
package main

import "fmt"

func main() {
	var lang = new([20]int)
	lang[10] = 100
	fmt.Printf("数据类型：%T\n存储的值：%d\n", lang, *lang)
}

// root@master01:/home/pc/Desktop/test# go run .
// 数据类型：*[20]int
// 存储的值：[0 0 0 0 0 0 0 0 0 0 100 0 0 0 0 0 0 0 0 0]
```

多维数组

```go
package main

import "fmt"

func main() {
    // 语法  var <name> [外层size][内层size]type
	// 多为数组 [[python php perl] [c go java]]
	var lang [2][3]string
	lang[0][0] = "python"
	lang[0][1] = "php"
	lang[0][2] = "perl"
	lang[1][0] = "c"
	lang[1][1] = "go"
	lang[1][2] = "java"

	fmt.Println(lang)

	for i := 0; i < len(lang); i++ {
		for _, v := range lang[i] {
			fmt.Println(v)

		}
	}
}
```

#### **切片 slice**

切片长度可变。又称为动态数组

声明语法：

```go
var <name> []type
```

+ `var` 关键字，表示声明一个变量
+ `<name>` 变量名称
+ `[]type`  指定元素数据类型

示例：

```go
package main

import "fmt"

func main() {
	var lang []string
	lang = append(lang, "python")
	lang = append(lang, "go")

	fmt.Printf("变量类型：%T\n切片元素数量: %d\n切片容量: %d\n变量内容：%s\n", lang, len(lang), cap(lang), lang)
	// 变量类型：[]string
	// 切片元素数量: 2
	// 切片容量: 2
	// 变量内容：[python go]
}
```

**使用make创建切片**

```go
package main

import "fmt"

func main() {
	// make(t Type, size ...IntegerType) ,3 切片长度，5 切片容量
	var lang = make([]string, 3, 5)
	// 追加两个元素
	lang = append(lang, "python", "go")

	fmt.Printf("数据类型：%T\n切片长度:%d\n切片容量：%d\n变量内容：%s\n最后一个元素: %s\n", lang, len(lang), cap(lang), lang, lang[len(lang)-1])
	// 数据类型：[]string
	//
	// 切片长度:5
	// 切片容量：5
	// 变量内容：[   python go]
	// 最后一个元素: go
	for k, v := range lang {
		fmt.Println(k, "-->", v)
	}
	// 0 -->
	// 1 -->
	// 2 -->
	// 3 --> python
	// 4 --> go
}
```



**截取数组作为切片**

```go
package main

import "fmt"

func main() {
	var lang = [5]string{"python", "go", "c", "java", "perl"}
	var langSlice = lang[:]
	fmt.Printf("数据类型：%T\n切片长度:%d\n切片容量：%d\n变量内容：%s\n", langSlice, len(langSlice), cap(langSlice), langSlice)
	// 数据类型：[]string
	// 切片长度:5
	// 切片容量：5
	// 变量内容：[python go c java perl]
}
```



**append()函数**

```go
package main

import "fmt"

// append() 函数向切片追加元素
func main() {
	var lang = []string{"python", "java"}
	lang = append(lang, "go", "c")
	fmt.Println(lang) //[python java go c]
	// 追加一个切片
	lang = append(lang, []string{"sql", "bash"}...)
	fmt.Println(lang) //[python java go c sql bash]

	// 像指定位置插入。此过程利用了append的嵌套
	// append([]string{"ruby"}, lang[1:]...) 把lang[:1]切片内容添加到切片[]string{"ruby"}
	lang = append(lang[:1], append([]string{"ruby"}, lang[1:]...)...)
	fmt.Println(lang) //[python ruby java go c sql bash]
}
```

**copy()函数**

```go
package main

import "fmt"

func main() {
	var lang = []string{"python", "java", "go"}
	langCopy := make([]string, len(lang))
	// copy(目标切片，原切片)
	copy(langCopy, lang)
	fmt.Println(langCopy) //[python java go]
}
```



#### 集合 map

存放相同数据类型元素，可变长，无序

声明语法：

```go
var <name> map[keytype]valuetype
```

+ `var` 关键字，表示声明一个变量

+ `<name>` 变量名称

+ `map[keytype]valuetype` map 为关键字 `[keytype]`表示key的数据类型 `valuetype` 表示value的数据类型

  

示例：

```go
package main

import "fmt"

func main() {
    // map 声明后并不能直接使用，声明时并没有分配内存地址。因此需要make执行初始化。
	var lang map[string][]string
	lang = make(map[string][]string)
	lang["python"] = []string{"吉多·范罗苏姆"}
	lang["go"] = []string{"罗伯特·格瑞史莫", "罗布·派克", "肯·汤普逊"}
	fmt.Println(lang) // 打印：map[python:[吉多·范罗苏姆] go:[罗伯特·格瑞史莫 罗布·派克 肯·汤普逊]]
}
```

**声明并初始化**

```go
package main

import "fmt"

func main() {
	var lang = map[string][]string{
		"python": []string{"吉多·范罗苏姆"},
		"go":     []string{"罗伯特·格瑞史莫", "罗布·派克", "肯·汤普逊"},
	}
	fmt.Println(lang) //map[go:[罗伯特·格瑞史莫 罗布·派克 肯·汤普逊] python:[吉多·范罗苏姆]]
}

```



**make()**

```go
package main

import "fmt"

func main() {
	// 集合，存放key value 键值对，类似python中的字典
	var lang = make(map[string][]string)

	fmt.Printf("数据类型：%T\n", lang) // 数据类型：map[string][]string

	lang["python"] = []string{"吉多·范罗苏姆"}
	lang["go"] = []string{"罗伯特·格瑞史莫", "罗布·派克", "肯·汤普逊"}
	fmt.Println(lang) // 打印：map[python:[吉多·范罗苏姆] go:[罗伯特·格瑞史莫 罗布·派克 肯·汤普逊]]
	for k, v := range lang {
		fmt.Printf("%s >>> %s\n", k, v)
	}
	// python >>> [吉多·范罗苏姆]
	// go >>> [罗伯特·格瑞史莫 罗布·派克 肯·汤普逊]
}
```



**判断key是否存在map中**

```go
package main

import "fmt"

func main() {
	var lang = map[string][]string{
		"python": []string{"吉多·范罗苏姆"},
		"go":     []string{"罗伯特·格瑞史莫", "罗布·派克", "肯·汤普逊"},
	}
	if value, keyExist := lang["c"];keyExist{ //[] false
		fmt.Println(value) 
	}else{
		fmt.Println("不存在")
	}
}
```



#### 结构体 struct

> 通过结构体可以自定义数据类型



声明语法：

```go
type <name> struct {
	filed1 filedtype
	filed1 filedtype
	...
}
```

+ `type` 关键字
+ `<name>` 结构体名称，首字符大写表示可以被其他包引用
+ `struct`表示声明结构体类型

示例：

```go
package main

import "fmt"

func main() {
    // 约定： 首字符大写表示为可以导出的变量和字段
	type Persion struct {
		Name    string
		Age     int8
		Sex     bool
		Favorit []string
	}

	var persion Persion
	persion.Name = "张三"
	persion.Age = 33
	persion.Sex = true
	fmt.Printf("%+v\n%v\n", persion, persion)
	// {Name:张三 Age:33 Sex:true Favorit:[]}
	// {张三 33 true []}
}
```



*示例声明一个alertmanager 告警规则的结构体*

```go
package main

import (
	"encoding/json"
	"fmt"
)

// AlertStatus represents the status of an alert.
type AlertStatus struct {
	Status       string
	Labels       map[string]string `json:"labels"`
	Annotations  map[string]string `json:"annotations"`
	StartsAt     string            `json:"startsAt"`
	EndsAt       string            `json:"endsAt"`
	GeneratorURL string            `json:"generatorURL"`
	Fingerprint  string            `json:"fingerprint"`
}

// Alert represents the structure of an alert.
type Alert struct {
	Receiver          string            `json:"receiver"`
	Status            string            `json:"status"`
	Alerts            []AlertStatus     `json:"alerts"`
	GroupLabels       map[string]string `json:"groupLabels"`
	CommonLabels      map[string]string `json:"commonLabels"`
	CommonAnnotations map[string]string `json:"commonAnnotations"`
	ExternalURL       string            `json:"externalURL"`
	Version           string            `json:"version"`
	GroupKey          string            `json:"groupKey"`
	TruncatedAlerts   int               `json:"truncatedAlerts"`
}

func main() {
	// JSON content as a raw string.
	jsonData := `{
		"receiver": "webhook",
		"status": "firing",
		"alerts": [
			{
				"status": "firing",
				"labels": {
					"alertname": "cpu3",
					"instance": "localhost:9100",
					"job": "node_exporter",
					"severity": "warning"
				},
				"annotations": {
					"description": "localhost:9100 of job node_exporter has been used cpu >0 more than 5 minutes. (current value: 44.99%)",
					"summary": "Instance localhost:9100 cpu usage high"
				},
				"startsAt": "2024-04-21T09:36:36.26148042Z",
				"endsAt": "0001-01-01T00:00:00Z",
				"generatorURL": "",
				"fingerprint": "c4c0776a34942165"
			}
		],
		"groupLabels": {
			"alertname": "cpu3"
		},
		"commonLabels": {
			"alertname": "cpu3",
			"instance": "localhost:9100",
			"job": "node_exporter",
			"severity": "warning"
		},
		"commonAnnotations": {
			"description": "localhost:9100 of job node_exporter has been used cpu >0 more than 5 minutes. (current value: 44.99%)",
			"summary": "Instance localhost:9100 cpu usage high"
		},
		"externalURL": "http://e7b40e5c9054:9093",
		"version": "4",
		"groupKey": "{}:{alertname=\"cpu3\"}",
		"truncatedAlerts": 0
	}`

	// Declare a variable of type Alert to hold the unmarshalled data.
	var alert Alert

	// Unmarshal the JSON data into the struct.
	err := json.Unmarshal([]byte(jsonData), &alert)
	if err != nil {
		fmt.Println("Error unmarshalling JSON:", err)
		return
	}

	// Print the unmarshalled data.
	fmt.Printf("%+v\n", alert)

}
```





### 运算符

> 算术运算符中 `%` 仅仅使用于整数类型，其他符号可用于整数、浮点数、复数的运算

<table>
    <tr>
        <td>算术运算</td>
        <td>+</td>
        <td>-</td>
        <td>*</td>
        <td>/</td>
        <td>%</td>
        <td>++</td>
        <td>--</td>
    </tr>
    <tr>
        <td>赋值运算</td>
        <td>=</td>
        <td>+=</td>
        <td>-=</td>
        <td>*=</td>
        <td>/=</td>
        <td>%=</td>
        <td></td>
    </tr>
    <tr>
        <td>比较运算</td>
        <td>==</td>
        <td>!=</td>
        <td><</td>
        <td><=</td>
        <td>></td>
        <td>>=</td>
        <td></td>
    </tr>
    <tr>
        <td>逻辑运算</td>
        <td>&&</td>
        <td>||</td>
        <td>!</td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td>位运算</td>
        <td>&</td>
        <td>|</td>
        <td>^</td>
        <td><<</td>
        <td>>></td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td>指针运算符</td>
        <td>&</td>
        <td>*</td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
    </tr>
</table>



幂运算需要使用math包下的 pow()函数

+ 算术运算符

  ```go
  package main
  
  // 假设一个收银系统
  
  import "fmt"
  
  func main() {
  	//  重量和单价
  	weigh, price := 2.18, 1.99
  	// 称重去皮
  	weigh -= 0.1
  	// 总价
  	total := weigh * price
  	fmt.Printf("应付金额：%2.1f\n", total)
  }
  ```

  

