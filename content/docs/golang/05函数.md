---
title: "函数"
linkTitle: "函数"
date: 2025-05-09
toc_hide: false
hide_summary: true
weight: 5
description: >
  go|函数

tags: ["golang","函数"]
categories: ["golang"]
url: golang/function.html
---



### 函数

**函数定义基本语法**

```go
func func_name(params) (return_types) {
    
}
```

+ `func` 关键字表示定义一个函数
+ `func_name` 函数名称
+ `params`  形参
+ `return_types` 返回值类型



示例：

```go
package main

import "fmt"

func main() {
	sum := add(1, 2)
	fmt.Println(sum) //3
}

func add(a, b int) int {
	return a + b
}
```



+ **基本函数，没有参数和返回值**

  ```go
  package main
  
  import "fmt"
  
  func main() {
  	add()
  }
  func add() {
  	fmt.Println(1 + 2)
  }
  ```

+ **可以传递参数的函数**

  ```go
  package main
  
  import "fmt"
  
  func main() {
  	add(1, 2)
  }
  func add(a, b float32) {
  	fmt.Println(a + b)
  }
  ```

+ **传递可变参数**

  ```go
  package main
  
  import "fmt"
  
  func main() {
  	add(1, 2, 3, 4, 5)
  }
  func add(num ...int) {
  	sum := 0
  	for _, v := range num {
  		sum += v
  	}
  	fmt.Println(sum)
  }
  ```

  

  ```go
  package main
  
  import "fmt"
  
  func main() {
  	add([]int{1, 2, 3, 4, 5})
  	
  }
  
  func add(num []int) {
  	sum := 0
  	for _, v := range num {
  		sum += v
  	}
  	fmt.Println(sum)
  }
  
  ```

  

+ **有返回值的函数**

  ```go
  package main
  
  import "fmt"
  
  func main() {
  	result, mesg := add(1, 2, 3, 4, 56)
  	fmt.Println(result, mesg)
  }
  func add(num ...int) (int, string) {
  	sum := 0
  	for _, v := range num {
  		sum += v
  	}
  	return sum, "计算完成"
  }
  ```

  **命名返回值**

  ```go
  package main
  
  import (
  	"fmt"
  )
  
  func main() {
  	result, mesg := add(1, 2, 3, 4, 56)
  	fmt.Println(result, mesg)
  }
  func add(num ...int) (sum int, mesg string) {
  	for _, v := range num {
  		sum += v
  	}
  	mesg = "计算完成"
  	return
  }
  ```

+ **参数值传递和引用传递**

  值传递，复制变量值给函数，不会影响原有变量

  ```go
  package main
  
  import "fmt"
  
  func main() {
  	num1 := 1
  	num2 := 2
  	swap(num1, num2)
  	fmt.Printf("num1的值：%d\nnum2的值：%d\n", num1, num2)
  	// num1的值：1
  	// num2的值：2
  
  }
  
  func swap(a, b int) {
  	a, b = b, a
  }
  
  ```

  引用传递，会修改原有变量

  ```go
  package main
  
  import "fmt"
  
  func main() {
  	num1 := 1
  	num2 := 2
  	swap(&num1, &num2)
  	fmt.Printf("num1的值：%d\nnum2的值：%d\n", num1, num2)
  	// num1的值：2
  	// num2的值：1
  
  }
  
  func swap(a, b *int) {
  	*a, *b = *b, *a
  }
  ```

### 递归函数

+ **函数体内调用函数自身 称为递归函数**

  ```go
  package main
  
  import "fmt"
  
  func main() {
  	// 斐波那契数列是指这样一个数列：1，1，2，3，5，8，13，21，34，55，89……这个数列从第3项开始 ，每一项都等于前两项之和
  	for i := 1; i <= 10; i++ {
  		fmt.Println(sum(i))
  	}
  }
  
  // 求第n项
  func sum(n int) int {
  	if n <= 2 {
  		return 1
  	} else {
  		return sum(n-1) + sum(n-2)
  	}
  }
  ```

  ```go
  package main
  
  import "fmt"
  
  func main() {
  	for i := 1; i <= 10; i++ {
  		fmt.Println(test4(i))
  	}
  }
  
  // 递归函数
  func test4(a int) int {
  
  	if a == 1 {
  		return 1
  	}
  	return test4(a-1) + a
  }
  ```

  



### 匿名函数

**函数定义基本语法**

```go
// 省略了函数的名称
func(params) (return_types) {
    
}
```

+ `func` 关键字表示定义一个函数
+ `params`  形参
+ `return_types` 返回值类型

示例：

```go
package main

import "fmt"

func main() {
	result, mesg := func(num ...int) (int, string) {
		sum := 0
		for _, v := range num {
			sum += v
		}
		return sum, "计算完毕"
	}(1, 2, 3, 4, 5)
	fmt.Println(result, mesg)
}
```



+ 将匿名函数赋值给一个变量

  ```go
  package main
  
  import "fmt"
  
  func main() {
  	f1 := func(num ...int) (sum int, mesg string) {
  		for _, v := range num {
  			sum += v
  		}
  		mesg = "计算完毕"
  		return
  	}
  	result, mesg := f1(1, 2, 3, 4, 5)
  	fmt.Println(result, mesg)
  }
  ```

  

### 回调函数

+ 利用匿名函数实现回调

  ```go
  package main
  
  import "fmt"
  
  func main() {
  	operator(func() {
  		fmt.Println("hello world")
  	})
  }
  
  func operator(f func()) { // f  func() 表示 f 变量是一个无参数，无返回值的函数
  	f()  // 在此处回调了函数f
  }
  ```

  **带参数的回调函数**
  
  ```go
  package main
  
  import "fmt"
  
  func main() {
  	// 把函数作为参数,回调函数
  
  	add := func(a, b int) int {
  		return a + b
  	}
  
  	fmt.Print(
  		operator(1, 2, add),
  	)
  
  }
  func operator(a, b int, fun func(int, int) int) int {
  	result := fun(a, b)
  	return result
  }
  ```
  
  ```go
  package main
  
  import "fmt"
  
  func main() {
  	// 把函数作为参数,回调函数
  
  	fmt.Print(
  		operator(1, 2, func(a, b int) int {
  			return a + b
  		}),
  	)
  
  }
  func operator(a, b int, fun func(int, int) int) int {
  	result := fun(a, b)
  	return result
  }
  ```

### 闭包函数

> 把函数作为返回值，这个函数保存了变量不被释放

+ 利用匿名函数实现闭包

  ```go
  package main
  
  import "fmt"
  
  func main() {
  	result := add()
  	result()
  }
  
  func add() func() {
  	return func() {
  		fmt.Println(123)
  	}
  }
  ```

  ```go
  package main
  
  import "fmt"
  
  func main() {
  	//  add 函数已经结束，但是result 保留了变量num的变量值
  	result := add(123)
  
  	for i := 0; i < 10; i++ {
  		result()
  		// 124
  		// 125
  		// 126
  		// 127
  		// 128
  		// 129
  		// 130
  		// 131
  		// 132
  		// 133
  	}
  
  }
  
  func add(num int) func() {
  	return func() {
  		num++
  		fmt.Println(num)
  	}
  }
  ```

### 函数延迟调用



+ defer 声明位置，暂存当前变量状态。类似一个快照

  ```go
  package main
  
  import "fmt"
  
  func main() {
  	a := 1
  	defer fmt.Println(a) //1
  	a++
  	fmt.Println(a) //2
  }
  ```

  

+ 多个defer 函数按照顺序逆序执行，暂存defer任务的地方类似栈

  ```go
  package main
  
  func main() {
  	a := []string{"1", "2", "3"}
  	for _, v := range a {
  		defer println(v)
  		// 3
  		// 2
  		// 1
  	}
  }
  ```

  





### 冒泡排序函数示例





![冒泡排序](../docs/golang/static/冒泡排序.png)



```go
package main

import "fmt"

func main() {
	result := sort([]string{"3", "0", "9", "1", "4"})
	fmt.Println(result) //[0 1 3 4 9]
}

// 一个冒泡比较的函数
func sort(a []string) []string {
	for i := 1; i < len(a); i++ { //比较的轮数
		for j := 0; j < len(a)-i; j++ { // 每轮比较的次数
			if a[j] > a[j+1] {
				a[j], a[j+1] = a[j+1], a[j]
			}
		}
	}
	return a
}
```







