---
title: "os"
linkTitle: "os"
date: 2025-05-09
toc_hide: false
hide_summary: true
weight: 3
description: >
  os|标准库

tags: ["golang","库","os"]
categories: ["golang","库"]
url: golang/package/os.html
---






####  os操作文件系统

+ **`os.Create()` 创建文件或清空文件**

  ```go
  package main
  
  import (
    "fmt"
    "os"
  )
  
  func main() {
    // 创建文件或清空文件 如果文件不存在则创建默认权限0644，如果文件存在文件中内容会被清空
    if f, err := os.Create("1.txt"); err != nil {
        fmt.Println(err)
    } else {
        defer f.Close()
        fmt.Fprintln(f, "创建了一个文件,并向文件中写入了一行")
    }
  
  }
  ```

  

+ **`os.Mkdir()` 创建目录**

  ```go
  package main
  
  import (
    "fmt"
    "os"
  )
  
  func main() {
    // os.Mkdir() 创建目录,可以看作是linux中mkdir
    if err := os.Mkdir("newdir", 0755); err != nil {
        fmt.Println(err) //目录如果存在时执行报错：mkdir newdir: file exists
    }
  }
  ```

+ **`os.MkdirAll()`递归创建目录**

  ```go
  package main
  
  import (
    "fmt"
    "os"
  )
  
  func main() {
    // 递归创建目录
    if err := os.MkdirAll("newdir1/newdir2", 0755); err != nil {
        fmt.Println(err) //当目录存在时不会报错
    }
  }
  ```

+ **`os.Rename()` 移动目录**

  ```go
  package main
  
  import (
    "fmt"
    "os"
  )
  
  func main() {
    // mv 目录
    if err := os.Rename("newdir1", "/tmp/newdir1"); err != nil {
        // 当目标已经存在时报错：rename newdir1 /tmp/newdir1: file exists
        // 当目标是文件时报错：rename newdir1 /tmp/newdir1: not a directory
        fmt.Println(err)
    }
  }
  ```

   

+ **`os.Open()` 只读方式打开文件**

  ```go
  package main
  
  import (
    "fmt"
    "io"
    "os"
  )
  
  func main() {
    // os.Open() 只读方式打开文件
    if f, err := os.Open("/etc/hosts1"); err != nil {
        fmt.Print(err) //如果文件不存在报错：open /etc/hosts1: no such file or directory
    } else {
        defer f.Close()
        // 分批次循环读取文件
        var buffer [128]byte
        var result []byte
        for {
  
            lenth, err := f.Read(buffer[:])
            if err == io.EOF {
                break
            }
            result = append(result, buffer[:lenth]...)
  
        }
        fmt.Println(string(result))
    }
  }
  ```

+ **`os.OpenFile()` 整合并扩展了`os.Create()`，`os.Open()`功能**

  ```go
  package main
  
  import (
    "fmt"
    "os"
  )
  
  func main() {
  
    //  O_CREATE create a new file if none exists.
    //  O_RDONLY open the file read-only.
    //  O_WRONLY open the file write-only.
    //  O_RDWR open the file read-write.
    //  O_APPEND append data to the file when writing.
  
    f, err := os.OpenFile("1.txt", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
    if err != nil {
        fmt.Println(err)
    }
    fmt.Fprintln(f, "追加一条信息到文本")
  }
  
  ```

+ **`os.Remove() 和 os.RemoveAll()`文件删除**

  ```go
  package main
  
  import (
    "fmt"
    "os"
  )
  
  func main() {
    // 删除文件 或 空目录[目录下有目录或文件不能被删除]
    var fileList = []string{}
    os.Create("1.txt")
    os.MkdirAll("dir1/dir2", 0755)
    fileList = append(fileList, "1.txt")
    fileList = append(fileList, "dir1")      //remove dir1: directory not empty
    fileList = append(fileList, "dir1/dir2") 
    for _, fileName := range fileList {
        if err := os.Remove(fileName); err != nil {
            fmt.Println(err)
            continue
        }
    }
  
  }
  ```

  ```go
  package main
  
  import (
    "fmt"
    "os"
  )
  
  func main() {
    // 删除文件 或 目录
    var fileList = []string{}
    os.Create("1.txt")
    os.MkdirAll("dir1/dir2", 0755)
    fileList = append(fileList, "1.txt")
    fileList = append(fileList, "dir1")
  
    for _, fileName := range fileList {
        if err := os.RemoveAll(fileName); err != nil {
            fmt.Println(err)
        }
    }
  
  }
  ```

+ **`os.Stat()` 文件状态**

  ```go
  package main
  
  import (
    "fmt"
    "os"
  )
  
  func main() {
    if fileInfo, err := os.Stat("/etc/hosts"); err != nil {
        fmt.Println(err)
    } else {
        // 文件名，basename /etc/hosts
        filename := fileInfo.Name()
        fmt.Println(filename)
  
        // 文件大小
        size := fileInfo.Size()
        fmt.Printf("%d bytes\n", size)
  
        if fileInfo.IsDir() {
            fmt.Println("是目录")
        } else {
            fmt.Println("是文件")
        }
    }
  }
  ```
  

+ **`os.Args` 获取命令行传递的参数**

  ```go
  package main
  
  import (
          "fmt"
          "os"
  )
  
  func main() {
  
          fmt.Println(os.Args[1:])
  }
  ```

  ```bash
  [root@golang ~]# go run test.go  123 455 789
  [123 455 789]
  ```

  


+ **os/exec 执行系统命令**

  ```go
  package main
  
  import (
  	"fmt"
  	"log"
  	"os/exec"
  )
  
  func main() {
  	cmd := exec.Command("ls", "-l") // 更改为你需要执行的命令和参数
  
  	output, err := cmd.CombinedOutput()
  	if err != nil {
  		log.Fatal(err)
  	}
  
  	fmt.Println(string(output))
  }
  ```

**示例：**

+ **os获取环境变量**

  ```go
  package main
  
  import (
      "fmt"
      "os"
  )
  
  func main() {
      // 获取系统环境变量
      hostname := os.Getenv("USER")
  
      uid := os.Geteuid()
  
      fmt.Printf("当前用户名:%s\n当前用户uid:%d\n", hostname, uid)
  }
  ```

  

+ **文件读写示例**

  ```go
  package main
  
  import (
      "fmt"
      "io"
      "os"
  )
  
  func main() {
      readFile("email04.png", "email041.png")
  }
  
  func readFile(oldfile, newfile string) {
      // 实现文件的复制
      file, err := os.Open(oldfile)
      if err != nil {
          fmt.Println(err)
      }
  
      var buffer [128]byte
      var result []byte
      for {
          if seed, err := file.Read(buffer[:]); err != nil && err == io.EOF {
              fmt.Println("文件读取完毕")
              break
  
          } else {
              result = append(result, buffer[:seed]...)
          }
      }
      if f, err := os.OpenFile(newfile, os.O_CREATE|os.O_APPEND|os.O_RDWR, 0644); err != nil {
          fmt.Println(err)
          defer f.Close()
      } else {
          defer f.Close()
          f.Write(result)
      }
  }
  ```